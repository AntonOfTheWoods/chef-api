{"name":"ChefAPI","tagline":"A tiny Chef API client with minimal dependencies","body":"ChefAPI Client\r\n==============\r\n[![Gem Version](http://img.shields.io/gem/v/chef-api.svg)][gem]\r\n[![Build Status](http://img.shields.io/travis/sethvargo/chef-api.svg)][travis]\r\n\r\n[gem]: https://rubygems.org/gems/chef-api\r\n[travis]: http://travis-ci.org/sethvargo/chef-api\r\n\r\n**ChefAPI is currently in rapid development!** You should not consider this API stable until the official 1.0.0 release.\r\n\r\nChefAPI is a dependency-minimal Ruby client for interacting with a Chef Server. It adopts many patterns and principles from Rails\r\n\r\n\r\nQuick start\r\n-----------\r\nInstall via Rubygems:\r\n\r\n    $ gem install chef-api\r\n\r\nor add it to your Gemfile if you are using Bundler:\r\n\r\n```ruby\r\ngem 'chef-api', '~> 0.1'\r\n```\r\n\r\nIn your library or project, you will likely want to include the `ChefAPI::Resource` namespace:\r\n\r\n```ruby\r\ninclude ChefAPI::Resource\r\n```\r\n\r\nThis will give you \"Rails-like\" access to the top-level Chef resources like:\r\n\r\n```ruby\r\nClient.all\r\nNode.all\r\n```\r\n\r\nIf you choose not to include the module, you will need to specify the full module path to access resources:\r\n\r\n```ruby\r\nChefAPI::Resource::Client.all\r\nChefAPI::Resource::Node.all\r\n```\r\n\r\n### Create a connection\r\nBefore you can make a request, you must give the ChefAPI your connection information and credentials.\r\n\r\n```ruby\r\nChefAPI.configure do |config|\r\n  # The endpoint for the Chef Server. This can be an Open Source Chef Server,\r\n  # Hosted Chef Server, or Enterprise Chef Server.\r\n  config.endpoint = 'https://api.opscode.com/organizations/meats'\r\n\r\n  # ChefAPI will try to determine if you are running on an Enterprise Chef\r\n  # Server or Open Source Chef depending on the URL you provide for the\r\n  # +endpoint+ attribute. However, it may be incorrect. If is seems like the\r\n  # generated schema does not match the response from the server, it is\r\n  # possible this value was calculated incorrectly. Thus, you should set it\r\n  # manually. Possible values are +:enterprise+ and +:open_source+.\r\n  config.flavor = :enterprise\r\n\r\n  # The client and key must also be specified (unless you are running Chef Zero\r\n  # in no-authentication mode). The +key+ attribute may be the raw private key,\r\n  # the path to the private key on disk, or an +OpenSSLL::PKey+ object.\r\n  config.client = 'bacon'\r\n  config.key    = '~/.chef/bacon.pem'\r\n\r\n  # If you are running your own Chef Server with a custom SSL certificate, you\r\n  # will need to specify the path to a pem file with your custom certificates\r\n  # and ChefAPI will wire everything up correctly. (NOTE: it must be a valid\r\n  # PEM file).\r\n  config.ssl_pem_file = '/path/to/my.pem'\r\n\r\n  # If you would like to be vulnerable to MITM attacks, you can also turn off\r\n  # SSL verification. Despite what Internet blog posts may suggest, you should\r\n  # exhaust other methods before disabling SSL verification. ChefAPI will emit\r\n  # a warning message for every request issued with SSL verification disabled.\r\n  config.ssl_verify = false\r\n\r\n  # If you are behind a proxy, Chef API can run requests through the proxy as\r\n  # well. Just set the following configuration parameters as needed.\r\n  config.proxy_username = 'user'\r\n  config.proxy_password = 'password'\r\n  config.proxy_address  = 'my.proxy.server' # or 10.0.0.50\r\n  config.proxy_port     = '8080'\r\nend\r\n```\r\n\r\nAll of these configuration options are available via the top-level `ChefAPI` object.\r\n\r\n```ruby\r\nChefAPI.endpoint = '...'\r\n```\r\n\r\nYou can also configure everything via environment variables (great solution for Docker-based usage). All the environment variables are of the format `CHEF_API_{key}`, where `key` is the uppercase equivalent of the item in the configuration object.\r\n\r\n```bash\r\n# ChefAPI will use these values\r\nexport CHEF_API_ENDPOINT=https://api.opscode.com/organizations/meats\r\nexport CHEF_API_CLIENT=bacon\r\nexport CHEF_API_KEY=~/.chef/bacon.pem\r\n```\r\n\r\nIf you prefer a more object-oriented approach (or if you want to support multiple simultaneous connections), you can create a raw `ChefAPI::Connection` object. All of the options that are available on the `ChefAPI` object are also available on a raw connection:\r\n\r\n```ruby\r\nconnection = ChefAPI::Connection.new(\r\n  endpoint: 'https://api.opscode.com/organizations/meats',\r\n  client:   'bacon',\r\n  key:      '~/.chef/bacon.pem'\r\n)\r\n\r\nconnection.clients.fetch('chef-webui')\r\nconnection.environments.delete('production')\r\n```\r\n\r\nIf you do not want to manage a `ChefAPI::Connection` object, or if you just prefer an alternative syntax, you can use the block-form:\r\n\r\n```ruby\r\nChefAPI::Connection.new do |connection|\r\n  connection.endpoint = 'https://api.opscode.com/organizations/meats'\r\n  connection.client   = 'bacon'\r\n  connection.key      = '~/.chef/bacon.pem'\r\n\r\n  # The connection object is now setup, so you can use it directly:\r\n  connection.clients.fetch('chef-webui')\r\n  connection.environments.delete('production')\r\nend\r\n```\r\n\r\n### Making Requests\r\nThe ChefAPI gem attempts to wrap the Chef Server API in an object-oriented and Rubyesque way. All of the methods and API calls are heavily documented inline using YARD. For a full list of every possible option, please see the inline documentation.\r\n\r\nMost resources can be listed, retrieved, created, updated, and destroyed. In programming, this is commonly referred to as \"CRUD\".\r\n\r\n#### Create\r\nThere are multiple ways to create a new Chef resource on the remote Chef Server. You can use the native `create` method. It accepts a list of parameters as a hash:\r\n\r\n```ruby\r\nClient.create(name: 'new-client') #=> #<Resource::Client name: \"new-client\", admin: false, ...>\r\n```\r\n\r\nOr you can create an instance of the object, setting parameters as you go.\r\n\r\n```ruby\r\nclient = Client.new\r\nclient.name = 'new-client'\r\nclient.save #=> #<Resource::Client name: \"new-client\", admin: false, ...>\r\n```\r\n\r\nYou can also mix-and-match the hash and object initialization:\r\n\r\n```ruby\r\nclient = Client.new(name: 'new-client')\r\nclient.validator = true\r\nclient.admin = true\r\nclient.save #=> #<Resource::Client name: \"new-client\", admin: false, ...>\r\n```\r\n\r\n#### Read\r\nMost resources have the following \"read\" functions:\r\n\r\n- `.list`, `.all`, and `.each` for listing Chef resources\r\n- `.fetch` for getting a single Chef resource with the given identifier\r\n\r\n##### Listing\r\nYou can get a list of all the identifiers for a given type of resource using the `.list` method. This is especially useful when you only want to list items by their identifier, since it only issues a single API request. For example, to get the names of all of the Client resources:\r\n\r\n```ruby\r\nClient.list #=> [\"chef-webui\", \"validator\"]\r\n```\r\n\r\nYou can also get the full collection of Chef resources using the `.all` method:\r\n\r\n```ruby\r\nClient.all #=> [#<Resource::Client name: \"chef-webui\", admin: false ...>,\r\n                #<Resource::Client name: \"validator\", admin: false ...>]\r\n```\r\n\r\nHowever, this is incredibly inefficient. Because of the way the Chef Server serves requests, this will make N+1 queries to the Chef Server. Unless you absolutely need every resource in the collection, you are much better using the lazy enumerable:\r\n\r\n```ruby\r\nClient.each do |client|\r\n  puts client.name\r\nend\r\n```\r\n\r\nBecause the resources include Ruby's custom Enumerable, you can treat the top-level resources as if they were native Ruby enumerable objects. Here are just a few examples:\r\n\r\n```ruby\r\nClient.first #=> #<Resource::Client name: \"chef-webui\" ...>\r\nClient.first(3) #=> [#<Resource::Client name: \"chef-webui\" ...>, ...]\r\nClient.map(&:public_key) #=> [\"-----BEGIN PUBLIC KEY-----\\nMIGfMA...\", \"-----BEGIN PUBLIC KEY-----\\nMIIBI...\"]\r\n```\r\n\r\n##### Fetching\r\nYou can also fetch a single resource from the Chef Server using the given identifier. Each Chef resource has a unique identifier; internally this is called the \"primary key\". For most resources, this attribute is \"name\". You can fetch a resource by it's primary key using the `.fetch` method:\r\n\r\n```ruby\r\nClient.fetch('chef-webui') #=> #<Resource::Client name: \"chef-webui\" ...>\r\n```\r\n\r\nIf a resource with the given identifier does not exist, it will return `nil`:\r\n\r\n```ruby\r\nClient.fetch('not-a-real-client') #=> nil\r\n```\r\n\r\n#### Update\r\nYou can update a resource using it's unique identifier and a list of hash attributes:\r\n\r\n```ruby\r\nClient.update('chef-webui', admin: true)\r\n```\r\n\r\nOr you can get an instance of the object and update the attributes manually:\r\n\r\n```ruby\r\nclient = Client.fetch('chef-webui')\r\nclient.admin = true\r\nclient.save\r\n```\r\n\r\n#### Delete\r\nYou can destroy a resource using it's unique identifier:\r\n\r\n```ruby\r\nClient.destroy('chef-webui') #=> true\r\n```\r\n\r\nOr you can get an instance of the object and delete it manually:\r\n\r\n```ruby\r\nclient = Client.fetch('chef-webui')\r\nclient.destroy #=> true\r\n```\r\n\r\n### Validations\r\nEach resource includes its own validations. If these validations fail, they exhibit custom errors messages that are added to the resource. For example, Chef clients **must** have a name attribute. This is validated on the client side:\r\n\r\n```ruby\r\nclient = Client.new\r\nclient.save #=> false\r\n```\r\n\r\nNotice that the `client.save` call returned `false`? This is an indication that the resource did not commit back to the server because of a failed validation. You can get the error(s) that prevented the object from saving using the `.errors` method on an instance:\r\n\r\n```ruby\r\nclient.errors #=> { :name => [\"must be present\"] }\r\n```\r\n\r\nJust like Rails, you can also get the human-readable list of these errors by calling `#full_messages` on the errors hash. This is useful if you are using ChefAPI as a library and want to give developers a semantic error:\r\n\r\n```ruby\r\nclient.errors.full_messages #=> [\"`name' must be present\"]\r\n```\r\n\r\nYou can also force ChefAPI to raise an exception if the validations fail, using the \"bang\" version of save - `save!`:\r\n\r\n```ruby\r\nclient.save! #=> InvalidResource: There were errors saving your resource: `name' must be present\r\n```\r\n\r\n### Objects on Disk\r\nChefAPI also has the ability to read and manipulate objects on disk. This varies from resource-to-resource, but the `.from_file` method accepts a path to a resource on disk and loads as much information about the object on disk as it can. The attributes are then merged with the remote resource, if one exists. For example, you can read a Client resource from disk:\r\n\r\n```ruby\r\nclient = Client.from_file('~/.chef/bacon.pem') #=> #<Resource::Client name: \"bacon\", admin: false, public_key: nil, private_key: \"...\" ...>\r\n```\r\n\r\n\r\nSearching\r\n---------\r\nChefAPI employs both search and partial search functionality.\r\n\r\n```ruby\r\n# Using regular search\r\nresults = Search.query(:node, '*:*', start: 1)\r\nresults.total #=> 5_000\r\nresults.rows.each do |result|\r\n  puts result\r\nend\r\n\r\n# Using partial search\r\nresults = PartialSearch.query(:node, { data: ['fqdn'] }, start: 1)\r\nresults.total #=> 2\r\nresults.rows.each do |result|\r\n  puts result\r\nend\r\n```\r\n\r\n\r\nFAQ\r\n---\r\n**Q: How is this different than [Ridley](https://github.com/RiotGames/ridley)?**<br>\r\nA: Ridley is optimized for highly concurrent connections with support for multiple Chef Servers. ChefAPI is designed for the \"average user\" who does not need the advanced use cases that Ridley provides. For this reason, the ChefAPI is incredibly opinionated about the features it will include. If you need complex features, take a look at [Ridley](https://github.com/RiotGames/ridley).\r\n\r\n\r\nDevelopment\r\n-----------\r\n1. Clone the project on GitHub\r\n2. Create a feature branch\r\n3. Submit a Pull Request\r\n\r\nImportant Notes:\r\n\r\n- **All new features must include test coverage.** At a bare minimum, Unit tests are required. It is preferred if you include acceptance tests as well.\r\n- **The tests must be be idempotent.** The HTTP calls made during a test should be able to be run over and over.\r\n- **Tests are order independent.** The default RSpec configuration randomizes the test order, so this should not be a problem.\r\n\r\n\r\nLicense & Authors\r\n-----------------\r\n- Author: Seth Vargo <sethvargo@gmail.com>\r\n\r\n```text\r\nCopyright 2013-2014 Seth Vargo\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n","google":"UA-12012976-11","note":"Don't delete this file! It's used internally to help with page regeneration."}